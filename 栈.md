### 加减乘除括号计算

​	**[20. 有效的括号](#20-有效的括号)**

​	[32. 最长有效括号](#32-最长有效括号)

### 单调栈

#### 递减栈

​	[739. 每日温度](#739-每日温度)

​	**[42. 接雨水](#42-接雨水)**⚡

#### 递增栈

​	**[84. 柱状图中最大的矩形](#84-柱状图中最大的矩形)**

​	[402. 移掉K位数字](#402-移掉K位数字)

​		[321. 拼接最大数](#321-拼接最大数)

​	[316. 去除重复字母](#316-去除重复字母)



## 栈的应用——加减乘除括号计算

计算机中的加减乘除运算就是用栈实现的，带括号的运算也是如此。原因是运算并不是直接顺序运算，乘除和括号会影响运算顺序。例如表达式 `a + b * c + d`，要先计算`e = b * c`，然后再把它的结果e参与到后面的运算中：`a + e + d`。

实现上：需要顺序遍历表达式中的操作数，并且先用一个容器存起来这些操作数，等遇到高优先级的运算符，先计算高优先级的。也就是说后进入容器的部分操作数反而会先进行运算，**容器需要满足后入先出的性质——即栈。**

另外，递归的本质就是栈，可以类比递归来思考这个问题。后序遍历的递归也可以做到先不计算这一层的结果，深入递归，计算中间的结果，把中间的结果返回后，再利用到返回值计算这一层的结果。



### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

Difficulty: **简单**


给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1.  左括号必须用相同类型的右括号闭合。
2.  左括号必须以正确的顺序闭合。

**示例 1：**

```
输入：s = "()"
输出：true
```

**示例 2：**

```
输入：s = "()[]{}"
输出：true
```

**示例 3：**

```
输入：s = "(]"
输出：false
```

**示例 4：**

```
输入：s = "([)]"
输出：false
```

**示例 5：**

```
输入：s = "{[]}"
输出：true
```

**提示：**

*   `1 <= s.length <= 10<sup>4</sup>`
*   `s` 仅由括号 `'()[]{}'` 组成

**思路：括号相关的是典型的栈的应用——后进入容器的可能先参与运算--后入先出。**

```java
	public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();
        for (char c : s.toCharArray()) {
            if (c == '(') {
                stack.push(')');
            } else if (c == '[') {
                stack.push(']');
            } else if (c == '{') {
                stack.push('}');
            } else if (stack.isEmpty() || stack.pop() != c) {
                return false;
            }
        }
        return stack.isEmpty();
    }
```



### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

Difficulty: **困难**


给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```

**提示：**

*   0 <= s.length <= 3 * 10<sup>4</sup>
*   `s[i]` 为 `'('` 或 `')'`

**方法1：栈。括号题第一时间就应该想到栈**

```java
    public int longestValidParentheses(String s) {
        int res = 0;
        Stack<Integer> stack = new Stack<>();
        //栈内存的是「最后一个没有被匹配的右括号的下标」。预先把-1压入栈，如果s="()"，1-(-1)=2。
        stack.push(-1);
        for (int i = 0; i < s.length(); i++) {
            //遇到'('，'('不会是有效对的结尾，直接入栈当前下标
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                //遇到')'，先把栈顶弹出来，
                //如果栈内空了，说明没有匹配。更新「最后一个没有被匹配的右括号的下标」
                //如果栈内没有空，说明当前和被弹出的栈顶配对，更新最长有效括号。
                stack.pop();
                if (stack.empty()) {
                    stack.push(i);
                } else {
                    res = Math.max(res, i - stack.peek());
                }
            }
        }
        return res;
    }
```

**方法2：动态规划。**

```java
public int longestValidParentheses(String s) {
        int[] dp = new int[s.length()];
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            //当前是')'才会有匹配
            if (i > 0 && s.charAt(i) == ')') {
                //如果前一个是'('，匹配成功，加上'('前面的匹配对，也就是dp[i - 2]
                if (s.charAt(i - 1) == '(') {
                    if (i - 2 >= 0) {
                        dp[i] = dp[i - 2] + 2;
                    } else {
                        dp[i] = 2;
                    }
                } //如果前一个是')'，应该根据前一个的最长有小括号，再往前看1个是不是(。比如((()))
                else if (i - dp[i - 1] - 1 >= 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    //如果往前能匹配上，并且前面还不为空，加上更前面的匹配对
                    if (i - dp[i - 1] - 2 >= 0) {
                        dp[i] = dp[i - 1] + 2 + dp[i - dp[i - 1] - 2];
                    } else {
                        dp[i] = dp[i - 1] + 2;
                    }
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
```



## 单调栈

很多单调栈会用到sentinel，也就是在遍历之前先往栈中push一个元素，作为边界值，排除一些特殊情况。比如[84. 柱状图中最大的矩形](#84-柱状图中最大的矩形)

**单调递减栈：**

**==用于O(1)快速获取左右第一个比它大的。==**对于栈中元素，栈中下一个元素就是左边第一个比它大的，然后在遍历过程中看是不是有比它大的就行了，**整个问题只需要一遍遍历O(N)。**

例如：**[42. 接雨水](#42-接雨水)**

**单调递增栈：**

**==用于O(1)快速获取左右第一个比它小的。==**对于栈中元素，栈中下一个元素就是左边第一个比它小的，然后在遍历过程中看是不是有比它小的就行了，**整个问题只需要一遍遍历O(N)。**

例如：**[84. 柱状图中最大的矩形](#84-柱状图中最大的矩形)**

**在做题的过程中多体会，一想到要找到左右大的或者小的就用单调栈。**



### [739\. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

Difficulty: **中等**


请根据每日 `气温` 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

例如，给定一个列表 `temperatures = [73, 74, 75, 71, 69, 72, 76, 73]`，你的输出应该是 `[1, 1, 4, 2, 1, 1, 0, 0]`。

**提示：**`气温` 列表长度的范围是 `[1, 30000]`。每个气温的值的均为华氏度，都是在 `[30, 100]` 范围内的整数。

**思路：找右边第一个比当前大的，用单调递减栈。非常简单**

```java
  	public int[] dailyTemperatures(int[] T) {
        Stack<Integer> stack = new Stack<>();
        int[] res = new int[T.length];
        for (int i = 0; i < T.length; i++) {
            while (!stack.isEmpty() && T[i] > T[stack.peek()]) {
                int idx = stack.pop();
                res[idx] = i - idx;
            }
            stack.push(i);
        }
        return res;
    }
```



### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

Difficulty: **困难**


给定 _n_ 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![](images/栈/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

**提示：**

*   `n == height.length`
*   0 <= n <= 3 * 10<sup>4</sup>
*   0 <= height[i] <= 10<sup>5</sup>

进阶：[407. 接雨水 II](https://leetcode-cn.com/problems/trapping-rain-water-ii/) 面试一般不会这么难

**方法1：动态规划。left[i]表示i左侧的最大值，即区间[0,i)的最大值，right[i]表示i右侧的最大值，即区间(i,len-1]的最大值。如果i位置比左右两侧的最大值要小，说明i位置可以存水。水量取决于短板**

```java
	public int trap(int[] height) {
        int res = 0;
        int[] left = new int[height.length];
        int[] right = new int[height.length];

        for (int i = 1; i < height.length - 1; i++) {
            left[i] = Math.max(left[i - 1], height[i - 1]);
        }
        for (int i = height.length - 2; i >= 0; i--) {
            right[i] = Math.max(right[i + 1], height[i + 1]);
        }
        for (int i = 1; i < height.length - 1; i++) {
            int min = Math.min(left[i], right[i]);
            if (height[i] < min) {
                res = res + (min - height[i]);
            }
        }
        return res;
    }
```

**方法2：单调递减栈。**对于当前位置能不能存水的关键是左右是不是比它大，**单调递减栈：**

**用于O(1)快速获取左右第一个比它大的。**对于栈中元素，栈中下一个元素就是左边第一个比它大的，然后在遍历过程中看是不是有比它大的就行了，**整个问题只需要一遍遍历O(N)。**

换一种理解方式：如果是单调递减数组，不能蓄水，因此需要把单调递减的先存起来，遇到后面大的数再看能不能在栈顶这个小的数的位置上蓄水。

```java
	public int trap(int[] height) {
        int res = 0;
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < height.length; i++) {
            //如果栈不空并且当前指向的高度大于栈顶高度就一直循环
            while (!stack.empty() && height[i] > height[stack.peek()]) {
                //取出要出栈的元素
                int h = height[stack.pop()];
                // 栈空，原栈顶元素和当前元素之间没有空隙了，不会再有雨水。
                if (!stack.empty()) {
                    //两堵墙之前的距离。
                    int distance = i - stack.peek() - 1;
                    int min = Math.min(height[stack.peek()], height[i]);
                    res = res + distance * (min - h);
                }
            }
            //当前指向的墙入栈
            stack.push(i);
        }
        return res;
    }
```

**方法3：双指针。**假设一开始`left-1`大于`right+1`，则之后`right`一直向左移动，直到`right+1`大于`left-1`。在这段时间内`right`所遍历的所有点都是左侧最高点`maxleft`大于右侧最高点`maxright`的，所以只需要判断`maxright`与当前高度的关系就能知道i处能不能蓄水。反之`left`右移，所经过的点只要判断`maxleft`与当前高度的关系就行。

```java
	public int trap(int[] height) {
        int leftMax = 0, rightMax = 0;
        int left = 0, right = height.length - 1;
        int res = 0;
        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] < leftMax) {
                    //当前值比leftMax小，并且一定比rightMax小，此处可以蓄水。
                    res += leftMax - height[left];
                } else {
                    //当前值比leftMax大，此处不能蓄水，更新leftMax。
                    leftMax = height[left];
                }
                left++;
            } else {
                if (height[right] < rightMax) {
                    res += rightMax - height[right];
                } else {
                    rightMax = height[right];
                }
                right--;
            }
        }
        return res;
    }
```

**直接用leftMax和rightMax比较会更容易理解：**

对于位置`left`而言，它左边最大值一定是left_max，右边最大值“大于等于”right_max，这时候，如果`left_max<right_max`成立，那么它就知道自己能存多少水了。无论右边将来会不会出现更大的right_max，都不影响这个结果。 所以当`left_max<right_max`时，我们就希望去处理left下标，反之，我们希望去处理right下标。

注意while循环结束条件是left<=right。

```java
	public int trap(int[] height) {
        int leftMax = 0, rightMax = 0;
        int left = 0, right = height.length - 1;
        int res = 0;
        while (left <= right) {
            if(leftMax < rightMax){
                res += Math.max(0, leftMax - height[left]);
                leftMax = Math.max(leftMax, height[left]);
                left++;
            }else{
                res += Math.max(0, rightMax - height[right]);
                rightMax = Math.max(rightMax, height[right]);
                right--;
            }
        }
        return res;
    }
```



方法4：韦恩图。很难想出来。[题解](https://leetcode-cn.com/problems/trapping-rain-water/solution/wei-en-tu-jie-fa-zui-jian-dan-yi-dong-10xing-jie-j/)

<img src="images/栈/53ab7a66023039ed4dce42b709b4997d2ba0089077912d39a0b31d3572a55d0b-trapping_rain_water.png" alt="trapping_rain_water.png" style="zoom:50%;" />

图1从左往右`S1+=max1且max1逐步增大`。图2从右往左`S2+=max2且max2逐步增大`。S1 + S2会覆盖整个矩形，并且：重复面积 = 柱子面积 + 积水面积。最终， 积水面积 = S1 + S2 - 矩形面积 - 柱子面积



### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

Difficulty: **困难**


给定 _n_ 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

![](images/栈/histogram.png)

<small style="display: inline;">以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。</small>

![](images/栈/histogram_area.png)

<small style="display: inline;">图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。</small>

**示例:**

```
输入: [2,1,5,6,2,3]
输出: 10
```

**思路：单调递增栈。**

最直接的想法是遍历每个柱子，以当前柱子的高度作为矩形的高 h，向左右拓展直至遇到比它小的，就矩形的宽度w。时间复杂度是O(N^2)。

上述写法中，我们需要再嵌套一层 while 循环来向左找到第一个比柱子 i 高度小的柱子，这个过程是 O(N)的； 那么我们可以 **O(1) 的获取柱子 i 左边第一个比它小的柱子吗？**答案就是单调增栈，对于栈中元素，栈中下一个元素就是左边第一个比它小的，然后在遍历过程中看是不是有比它小的就行了，**整个问题只需要一遍遍历O(N)。**

因此做法就很简单了，我们遍历每个柱子，若当前的柱子高度大于等于栈顶柱子的高度，就直接将当前柱子入栈，否则若当前的柱子高度小于栈顶柱子的高度，**说明当前栈顶柱子找到了右边的第一个小于自身的柱子**，那么就可以将栈顶柱子出栈来计算以其为高的矩形的面积了。**此时栈顶是弹出的柱子左边第一个小于自身的柱子**，因此获得了宽w。      

**或者可以说，单调递增栈用于快速获取左边和右边第一个比它小的。**

```java
   public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        int res = 0;
        for (int i = 0; i < heights.length; ++i) {
            while (stack.peek() != -1 && heights[stack.peek()] >= heights[i]) {
                res = Math.max(res, heights[stack.pop()] * (i - stack.peek() - 1));
            }
            stack.push(i);
        }
        while (stack.peek() != -1) {
            res = Math.max(res, heights[stack.pop()]
                    * (heights.length - stack.peek() - 1));
        }
        return res;
    }
```

**更简洁的写法：前后增加两个高度为0的柱子，起到了“哨兵”💂的作用。**

```java
	public int largestRectangleArea(int[] heights) {
        // 这里为了代码简便，在柱体数组的头和尾加了两个高度为 0 的柱体。
        int[] tmp = new int[heights.length + 2];
        System.arraycopy(heights, 0, tmp, 1, heights.length);

        Stack<Integer> stack = new Stack<>();
        int area = 0;
        for (int i = 0; i < tmp.length; i++) {
            // 对栈中柱体来说，栈中的下一个柱体就是其「左边第一个小于自身的柱体」；
            // 若当前柱体 i 的高度小于栈顶柱体的高度，说明 i 是栈顶柱体的「右边第一个小于栈顶柱体的柱体」。
            // 因此以栈顶柱体为高的矩形的左右宽度边界就确定了，可以计算面积
            while (!stack.isEmpty() && tmp[i] < tmp[stack.peek()]) {
                int h = tmp[stack.pop()];
                area = Math.max(area, (i - stack.peek() - 1) * h);
            }
            stack.push(i);
        }
        return area;
    }
```



### [402. 移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

Difficulty: **中等**


给定一个以字符串表示的非负整数 _num_，移除这个数中的 _k_ 位数字，使得剩下的数字最小。

**注意:**

*   _num_ 的长度小于 10002 且 ≥ _k。_
*   _num_ 不会包含任何前导零。

**示例 1 :**

```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```

**示例 2 :**

```
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200\. 注意输出不能有任何前导零。
```

示例 **3 :**

```
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```

**思路：要删掉前面的大的数，留下后面更小的数。快速找到右边更小的，用单调递增栈。**

即：维护一个单调递增栈，如果当前元素比栈顶小，并且还可以继续删除(k > 0)，就删除栈顶的元素。

注意特殊情况，比如遍历结束后还没有删够，还需要继续删除。再比如数前面是0，需要处理一下。这道题是把002改写成2就行了。

```java
public String removeKdigits(String num, int k) {
    int len = num.length();
    //corner case
    if (k == len) {
        return "0";
    }

    Stack<Character> stack = new Stack<>();
    int i = 0;
    while (i < num.length()) {
        //whenever meet a digit which is less than the previous digit, discard the previous one
        while (k > 0 && !stack.isEmpty() && stack.peek() > num.charAt(i)) {
            stack.pop();
            k--;
        }
        stack.push(num.charAt(i));
        i++;
    }

    // 还没删完，corner case like "1111"
    while (k > 0) {
        stack.pop();
        k--;
    }

    //construct the number from the stack
    StringBuilder sb = new StringBuilder();
    while (!stack.isEmpty()) {
        sb.append(stack.pop());
    }
    sb.reverse();

    //remove all the 0 at the head
    while (sb.length() > 1 && sb.charAt(0) == '0') {
        sb.deleteCharAt(0);
    }
    return sb.toString();
}
```



### [321. 拼接最大数](https://leetcode-cn.com/problems/create-maximum-number/)

Difficulty: **困难**


给定长度分别为 `m` 和 `n` 的两个数组，其元素由 `0-9` 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 `k (k <= m + n)` 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 `k` 的数组。

**说明:** 请尽可能地优化你算法的时间和空间复杂度。

**示例 1:**

```
输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]
```

**示例 2:**

```
输入:
nums1 = [6, 7]
nums2 = [6, 0, 4]
k = 5
输出:
[6, 7, 6, 0, 4]
```

**示例 3:**

```
输入:
nums1 = [3, 9]
nums2 = [8, 9]
k = 3
输出:
[9, 8, 9]
```

**思路：这道题考验抽象的能力。两个数组一共选出k个字母，直接选是很难判断该选哪一个的。但是如果只在一个数组中取k个呢？取k个相当于删除len-k个，也就是[402. 移掉K位数字](#402-移掉K位数字)。**

**假设我们从 nums1 中取了 k1 个，从 num2 中取了 k2 个，其中 k1 + k2 = k。而 k1 和 k2 这 两个子问题我们是会解决的。由于这两个子问题是相互独立的，因此我们只需要分别求解，然后将结果合并即可。**

```java
public int[] maxNumber(int[] nums1, int[] nums2, int k) {
    if (k == 0) return new int[0];
    String max = "0";
    //枚举所有的情况
    for (int i = Math.max(0, k - nums2.length); i <= nums1.length && i <= k; i++) {
        String mergeString = merge(removeKNum(nums1, i), removeKNum(nums2, k - i));
        max = max.compareTo(mergeString) > 0 ? max : mergeString;
    }

    int[] res = new int[k];
    for (int i = 0; i < res.length; i++) {
        res[i] = max.charAt(i) - '0';
    }
    return res;
}

//单调递减栈
private String removeKNum(int[] nums, int k) {
    int[] res = new int[k];
    k = nums.length - k;  //k从留几个变为删除几个
    Stack<Integer> stack = new Stack<>();
    for (int i = 0; i < nums.length; i++) {
        while (k > 0 && !stack.isEmpty() && nums[stack.peek()] < nums[i]) {
            stack.pop();
            k--;
        }
        stack.push(i);
    }
    while (k > 0) {
        stack.pop();
        k--;
    }
    StringBuilder sb = new StringBuilder();
    for (int n : stack) {
        sb.append(nums[n]);
    }
    // System.out.println("MAX_NUMBER: "+ sb);
    return sb.toString();
}

private String merge(String s1, String s2) {
    StringBuilder sb = new StringBuilder();
    int i = 0, j = 0;
    while (i < s1.length() && j < s2.length()) {
        //merge的不是直接取i和j处大的，如果相等，应该取数更大的那个 例如{6,7,4} 和 {6, 1, 1} 应该取第一个数组的6
        sb.append(s1.substring(i).compareTo(s2.substring(j)) > 0 ? s1.charAt(i++) : s2.charAt(j++));
    }
    if (i == s1.length()) {
        sb.append(s2.substring(j));
    } else {
        sb.append(s1.substring(i));
    }
    return sb.toString();
}
```



### [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

Difficulty: **中等**


给你一个字符串 `s` ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 **返回结果的字典序最小**（要求不能打乱其他字符的相对位置）。

**相同题：[1081. 不同字符的最小子序列](https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/)**

**示例 1：**

```
输入：s = "bcabc"
输出："abc"
```

**示例 2：**

```
输入：s = "cbacdcbc"
输出："acdb"
```

**提示：**

*   1 <= s.length <= 10<sup>4</sup>
*   `s` 由小写英文字母组成

**思路：如果后面有一个特别小的，前面的都需要删除，因此需要快速获取比它小的，首先明确它是一个单调递增栈的问题。**

但要保证每个字符都出现一次，也就是只有后面还有这个字符的时候，才可以删除，否则就不能删除，因此要统计每个字符的频率。

```java
public String removeDuplicateLetters(String s) {
    Stack<Character> stack = new Stack<>();

    // 维护一个计数器记录字符串中字符的数量
    // 因为输入为 ASCII 字符，大小 256 够用了
    int[] count = new int[256];
    for (int i = 0; i < s.length(); i++) {
        count[s.charAt(i)]++;
    }

    boolean[] inStack = new boolean[256];
    for (char c : s.toCharArray()) {
        // 每遍历过一个字符，都将对应的计数减一
        count[c]--;

        if (inStack[c]) continue;

        while (!stack.isEmpty() && stack.peek() > c) {
            // 若之后不存在栈顶元素了，则停止 pop
            if (count[stack.peek()] == 0) {
                break;
            }
            // 若之后还有，则可以 pop
            inStack[stack.pop()] = false;
        }
        stack.push(c);
        inStack[c] = true;
    }

    StringBuilder sb = new StringBuilder();
    while (!stack.empty()) {
        sb.append(stack.pop());
    }
    return sb.reverse().toString();
}
```



## 树的遍历

### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

Difficulty: **中等**


给定一个不含重复元素的整数数组 `nums` 。一个以此数组直接递归构建的 **最大二叉树** 定义如下：

1.  二叉树的根是数组 `nums` 中的最大元素。
2.  左子树是通过数组中 **最大值左边部分** 递归构造出的最大二叉树。
3.  右子树是通过数组中 **最大值右边部分** 递归构造出的最大二叉树。

返回有给定数组 `nums` 构建的 **最大二叉树** 。

**示例 1：**

![](https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg)

```
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

**示例 2：**

![](https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg)

```
输入：nums = [3,2,1]
输出：[3,null,2,null,1]
```

**提示：**

*   `1 <= nums.length <= 1000`
*   `0 <= nums[i] <= 1000`
*   `nums` 中的所有整数 **互不相同**

```java
 	public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode root = null, node = null;
        LinkedList<TreeNode> stack = new LinkedList<>();

        for (int i = 0; i < nums.length; ++i) {
            node = new TreeNode(nums[i]);
            while (!stack.isEmpty() && stack.peek().val < node.val) {
                // 出栈 - 栈顶是左边第一个大的值, node是右边第一个大的值
                root = stack.pop();

                // 条件2、3
                if (stack.isEmpty() || stack.peek().val > node.val) {
                    node.left = root;
                } else {
                    stack.peek().right = root;
                }
            }

            // 入栈
            stack.push(node);
        }

        // 只有一个: 左边第一个大的
        while (!stack.isEmpty()) {
            root = stack.pop();
            if (!stack.isEmpty()) {
                // 条件3
                stack.peek().right = root;
            }
        }

        // 最后出栈的就是root
        return root;
    }
```

